services:

  # deserializer:
  #   container_name: deserializer
  #   build:
  #     context: . # build context is project root
  #     dockerfile: docker/deserializer.Dockerfile
  #   privileged: true # required for forwarding CAN interface from host to container
  #   network_mode: host # ^
  #   restart: unless-stopped
  #   depends_on:
  #     - redis

    # TODO: Add the streamer service (Eshi)
  streamer:
    # TODO: Configure the build context and Dockerfile
    # build:
    #   context: .
    #   dockerfile: apps/streamer/Dockerfile

    # TODO: streamer depends on redis
    # depends_on:
    #   - redis

    # TODO: Add relevant environment variables:
    # environment:
    #   - REDIS_URL=redis://redis:6379/0
    #   - REDIS_STREAM_KEY=can:frames
    #   - EVENTHUB_CONNECTION_STRING=${EVENTHUB_CONNECTION_STRING}
    #   - EVENTHUB_NAME=${EVENTHUB_NAME}
    #   - PRE_ROLL_SECONDS=5
    #   - INACTIVE_GRACE_SECONDS=10

    # TODO: restart policy
    # restart: unless-stopped

  redis:
    container_name: redis
    image: redis:8.2.2 # using official redis image, version 8.2.2 for "stability"
    command: ["redis-server", "/usr/local/etc/redis/redis.conf"] # starting redis with custom config
    volumes:
      - ./docker/redis.conf:/usr/local/etc/redis/redis.conf:ro # mounting the redis config from host, read only
      - redis-data:/data # named volume for data persistence
    ports:
      # the host (127.0.0.1) sends traffic through port 6379
      # which is bound to the containers port 6379
      - "127.0.0.1:6379:6379"
    restart: unless-stopped # restarts the container if it crashes

volumes:
    redis-data: # named volume for redis data persistence
      driver: local